<html>
    <head>
        <meta charset="UTF-8">
        <script type="text/javascript" src="chas-antidot.js"></script>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <style type="text/css">
            * {
                margin: 0;
                padding: 0;
            }

            html {
                width: 100%;
                height: 100%;
                display: block;
                position: relative;
                background: #eaeaea;
            }

            body {
                display: block;
                position: relative;
                background: #fff;
                width: 980px;
                margin: 0 auto;
                box-sizing: border-box;
                padding: 20px;
                min-height: 100%;
                color: rgba(0, 0, 0, .87);
                font-size: 13px;
                font-family: "Tahoma", Arial, sans-serif;
                line-height: 1.35;
            }

            #wikipedia_state {
                width: 100%;
                height: 100px;
                line-height: 100px;
                text-align: center;
                font-size: 18px;
            }

            #wikipedia_state span {
                font-weight: bold;
            }

            h2 {
                margin-top: 18px;
                margin-bottom: 10px;
                text-transform: uppercase;
            }

            p + p {
                margin-top: 1.5em;
            }

            pre {
                margin-top: 8px;
            }

            img {
                max-width: 100%;
            }
        </style>
    </head>
    <body>
        <div id="wikipedia_state">Сайт ru.wikipedia.org <span>определение...</span></div>
        <script type="text/javascript">
            addEventListener("DOMContentLoaded", function () {
                chasAntidot.testSiteWithImg({
                    'url': 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',
                    'secondUrl': 'https://ru.wikipedia.org/favicon.ico',
                    'ifNotBlocked': function () {
                        document.getElementById('wikipedia_state').firstElementChild.innerHTML = "не заблокирован!";
                    },
                    'ifBlocked': function () {
                        document.getElementById('wikipedia_state').firstElementChild.innerHTML = "заблокирован!";
                    }
                });
            });
        </script>
        <h2>Принцип работы</h2>

        <p>Суть принципа заключается в проверке доступности статики сайта, в данном случае картинок, т.к. картинки генерируют события onLoad и onError. Если сайт заблокирован или недоступен вовсе, значит зайт заблокирован.</p>

        <p>Пример использования:
<pre><code>chasAntidot.testSiteWithImg({
    'url': 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',
    'secondUrl': 'https://ru.wikipedia.org/favicon.ico',
    'ifNotBlocked': function () {
    document.getElementById('wikipedia_state').firstElementChild.innerHTML = "не заблокирован!";
    },
    'ifBlocked': function () {
    document.getElementById('wikipedia_state').firstElementChild.innerHTML = "заблокирован!";
    }
    });</code></pre>
        </p>

        Википедия
        <b id="isWikiBlocked">
        </b>
        <br/>
        Ширина незагруженного изображения в Вашем браузере:
	<span id="unexistingImageWidth">
		<i>(определяется...)</i>
	</span>
        <br/>
        Высота незагруженного изображения в Вашем браузере:
	<span id="unexistingImageHeight">
		<i>(определяется...)</i>
	</span>
        <br/>
        <button onclick="test()">Перепроверить</button>
        <br/>
        <i>
            Совет: чтобы имитировать блокировку Википедии, используйте файл hosts
            или просто отключитесь от интернета и нажмите "Перепроверить".
            Изменения hosts вступают в силу не мгновенно.
        </i>
        <script>
            function message(wiki) {
                document.getElementById('isWikiBlocked').innerHTML = wiki;
                document.getElementById('unexistingImageWidth').innerHTML = chasAntidot.unexistingImage.offsetWidth;
                document.getElementById('unexistingImageHeight').innerHTML = chasAntidot.unexistingImage.offsetHeight;
            }
            ;
            function test() {
                chasAntidot.testSiteWithImg({
                    url: 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',
                    ifBlocked: function () {
                        message('заблокирована');
                    },
                    ifNotBlocked: function () {
                        message('не заблокирована');
                    },
                });
                message('<i>(определяется...)</i>');
            }
            ;
            test();
            function bannerDemo() {
                chasAntidot.createBanner(
                        'Вероятно, <a href="https://ru.wikipedia.org">Википедия</a> заблокирована. <a href="http://rublacklist.net" target="_blank">Узнайте, что делать!</a>',
                        {
                            url: 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',
                            secondImage: 'https://ru.wikipedia.org/favicon.ico',
                        }
                );
            }
            ;
        </script>
        <br/>
        Итак, недавно Роскомнадзор <a
            href="http://habrahabr.ru/post/265367/">предпринял попытку блокировки</a> Википедии.
        Попытка провалилась, и самое время перейти в контрнаступление.
        В статье под катом я покажу, что, если пользователь Х зашёл на сайт А,
        то сайт А может определить, заблокирован ли для пользователя другой сайт Б.
        <img src="https://hsto.org/storage2/65c/665/ca2/65c665ca2a024785914e05305fff73b2.jpg"/>
        <br/>
        А дальше, по <a
            href="http://habrahabr.ru/post/256339/">намечающейся традиции</a>, изложение пойдёт в вопросно-ответной форме.
        <h2>
            Для чего это вообще нужно?
        </h2>
        При обсуждении блокировки Википедии сообщество заметило два обстоятельства, которые весьма выгодны цензуре.
        <br/>
        Во-первых, Википедия использует HTTPS и, более того, HSTS.
        Это означает, что заблокирована энциклопедия может быть только целиком (с точностью до домена),
        но при этом перенаправить на пресловутую страницу с сообщением о блокировке нельзя.
        Вместо этого высвечивается сообщение об ошибке установления соединения.
        Это выглядит как внутренняя проблема Википедии и смягчает недовольство пользователя действиями Роскомнадзора;
        в то же время для развития правового государства необходима обратная связь.
        <br/>
        Во-вторых, даже если пользователи узнают о блокировке, многие из них просто не будут знать, что делать.
        Вешать перманентную плашку "Если заблокировали Википедию - качайте Tor Browser!" на неравнодушных сайтах как минимум странно;
        в то же время, оповещение пользователей о блокировке Википедии и способах её обхода необходимо.
        Решение поставленной проблемы и пытается дать настоящая статья.
        <habracut/>
        <h2>
            Хочу демку!
        </h2>
        <a href="https://nickkolok.github.io/chas-antidot/demo.html">Пожалуйста!</a>

        <h2>
            Как это работает?
        </h2>
        Создаётся невидимый блок HTML-кода, содержащий два изображения:
        одно контрольное - с заведомо несуществующего URL,
        второе сигнальное - любое изображение с проверяемого сайта.
        Если их размеры через некоторое время совпадают - значит, изображение с проверяемого сайта не загрузилось,
        то есть он либо "лежит" настолько, что не может отдавать даже статику, либо заблокирован.
        <h2>
            А подробнее?
        </h2>
        Изображение в HTML, вставлемое тэгом img, по умолчанию имеет размеры, определяемые самим файлом-картинкой.
        Изображение, которое загрузить не удалось, тоже имеет какие-то размеры - в разных браузерах разные.
        Вот они (ширина x высота):
        <ul>
            <li>
                Chrome 44.0.2403.155 - 0x0 (до загрузки), 20x20 (при неудачной загрузке)
            </li>
            <li>
                Firefox 37.0 - 24x24
            </li>
            <li>
                Opera 12.16 - 114x22
            </li>
        </ul>
        Получить размеры элемента на Javascript можно с помощью свойств элемента .offsetWidth и .offsetHeight
        <h2>
            А если вдруг сигнальное изображение по размерам совпадёт с тем, что отобразит браузер при ошибке?
        </h2>
        Это достаточно маловероятно, учитывая, что сравниваются и ширина, и высота.
        Можно запросить два изображения заведомо разных размеров и сравнить их полученные размеры.
        Если совпадут - загрузка прошла неуспешно.
        И всё же фавиконы в качестве единственных изображений лучше не дёргать.
        <h2>
            А исходники?
        </h2>
        <a href="https://github.com/nickkolok/chas-antidot">На гитхабе</a> под GPLv3.
        <h2>
            И как этим всем пользоваться?
        </h2>
        Постарался сделать код читабельным, хотя, конечно, это не освобождает меня от приведения примера.
<pre>
	chasAntidot.testSiteWithImg({
		url: 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',	//URL картинки-детектора
		ifBlocked: function(){message('заблокирована');},	//callback, если заблокировано
		ifNotBlocked: function(){message('не заблокирована');},	//callback, если не заблокировано
		time: 3500, //Время ожидания ответа в миллисекундах, по умолчанию 4000
		secondImage: 'https://ru.wikipedia.org/favicon.ico',	//URL второй картинки - необязательно
	});
</pre>
        Никаких дополнительных библиотек типа jQuery не требуется, всё на чистом JS.
        <h2>
            Хорошо, я готов информировать своих пользователей о возможной блокировке Википедии!
            Можно мне готовый код?
        </h2>
        Во-первых, в любом случае саму библиотеку лучше скачать к себе на сайт.
        github.io не застрахован от блокировок.
        Во-вторых, для чистого JS возможен, например, такой вариант:
<pre>
chasAntidot.createBanner(
	'Вероятно, &lt;a href="https://ru.wikipedia.org">Википедия&lt;/a> заблокирована. &lt;a href="http://rublacklist.net" target="_blank">Узнайте, что нужно сделать!&lt;/a>',
	{
		url: 'https://ru.wikipedia.org/static/images/project-logos/ruwiki.png',
		secondImage: 'https://ru.wikipedia.org/favicon.ico',
	}
);
</pre>
        <button onclick="bannerDemo()">Показать баннер, если Википедия заблокирована</button>
        <br/>
        Это, конечно, работает, но не очень красиво :)
        Патчи, добавляющие функции создания баннеров с использованием различных библиотек, приветствуются!

        <h2>
            А если действительно Википедия упадёт?
        </h2>
        На этот случай можно использовать схожий механизм, сравнивая доступность картинки напрямую и через какой-нибудь анонимайзер.
        Ресурс в таком случае можно считать заблокиованным тогда и только тогда,
        когда через анонимайзер картинка видна, а напрямую - нет.
        Правда, анонимайзер тоже может быть заблокирован, и тогда придётся проверять ещё и его доступность -
        например, запрашивая через него картинку с сайта самого РКН.

        <h2>
            Где ещё есть толк от этого в народном хозяйстве?
        </h2>
        <ul>
            <li>
                Мобильная версия Викпедии сможет точно вовремя предупредить пользователей о блокировке десктопной
                (они на разных адресах и на разных доменах), и наоборот.
            </li>
            <li>
                Вебмастер, установив на страницу скрипт с аналогичным принципом действия,
                сможет на лету менять ссылки на конечное количество заблокированных ресурсов на ссылки через прокси.
                Готового решения нет, но патчи принимаются.
            </li>
            <li>
                Можно точно выявлять пользователей, у которых заблокирован (неважно, госцензурой или работодателем) любимый сайт
                (ВКонтакте и т. д.) и предлагать им купить VPN/прокси или использовать бесплатный прокси с рекламой.
            </li>
            <li>
                Можно на клиенте определить факт использования TOR/I2P, запросив таким образом картинку с домена .onion / .i2p
                Правда, с трудом представляю, зачем это нужно, кроме того, не исключено, что TOR Browser умеет с этим бороться.
            </li>
            <li>
                Хотите знать, активен ли у вашего пользователя IPv6?
                Просто загрузите картинку на какой-нибудь IPv6-адрес.
                Или воспользуйтесь картинками на серверах кого-нибудь крупного (типа Гугла), поддерживающего новый протокол.
            </li>
            <li>
                А ещё в некоторых случаях можно определить DNS, которым пользуется клиент.
                Например, OpenNIC и прочие NameCoin/.bit
            </li>
            <li>
                В веб-интерфейсах роутеров тоже бывают картинки!
                А значит, модель роутера при желании тоже можно определить, даже если веб-интерфейс извне недоступен.
            </li>
            <li>
                Наконец, можно проверять принадлежность к определённой сети.
                Например, у некоторых провайдеров есть целые поддомены с сайтами, доступными только своим абонентам.
                Неужели там не найдётся ни одной картинки?
                Можно проверять и принадлежность к корпоративным сетям - если, конечно, знать, какие ресурсы доступны только изнутри.
                Может быть, вы хотите показывать что-то особенное пользователям, заходящим в сеть по вайфаю из московского метро?
                Из распространённой сети кафе?
                Тогда стоит поискать на соответствующей странице авторизации картинки, доступные только изнутри!
                Хотя нельзя не признать, что определение по IP иногда более оправданно.
            </li>
            <li>
                <b>Нельзя</b> с помощью chrome extension URLs проверить наличие любого расширения,
                в котором есть отдельные файлы-картинки.
                У меня всегда получается "битая" картинка.
            </li>
            <li>
                В некоторых старых браузерах (IE6?), не блокирующих доступ к локальным картинкам,
                вероятно, можно с довольно неплохой точностью определять версии установленных у пользователя прикладных программ
                (Libre Office, GIMP, MS Office, Adobe Photoshop и т. д.) - достаточно знать, какие картинки какого размера
                характерны для каждой из версий.
                Конечно, это сработает, только если программа установлена в директорию по умолчанию, но, например,
                такой приём позволит вывести на сайте инструкции по установке программы, отсутствующей у пользователя,
                но необходимой для работы с сайтом.
                <b>В современных браузерах, скорее всего, не работает.</b>
            </li>
        </ul>
    </body>
</html>
